import numpy

import monkdata as m

from dtree import *
# from drawtree import drawTree

monks = {'monk1':m.monk1, 'monk2':m.monk2, 'monk3':m.monk3}
monktests = {'monk1':m.monk1test, 'monk2':m.monk2test, 'monk3':m.monk3test}
# Entropy

entropyTable = {}
for key in monks:
	entropyTable[key] = entropy(monks[key])

print "\nEntropy table"
for key in sorted(entropyTable):
	print key, '\t', entropyTable[key]
#print len([item.attribute[4] for item in m.monk1 if item.attribute[4] ==1])


# Information Gain

infoGainTable = {}
for key in sorted(monks):
	gains = []
	for a in m.attributes:
		gains.append(averageGain(monks[key], a))
	infoGainTable[key] = dict(zip(m.attributes, gains))

print "\nInformation gain table"
line = ""
for a in m.attributes:
	line += '\t' + a.name
print line

for key in sorted(infoGainTable):
	line = key
	for a in sorted(infoGainTable[key]):
		line += '\t' + "{0:.5f}".format(infoGainTable[key][a])
	print line

# best attribute for monk1 is A5, monk2 is A5, monk3 is A2
print "\nBest attributes for first split:"
for key in sorted(monks):
	print key, bestAttribute(monks[key], m.attributes)


# 2 levels tree for monk1

class Split:
    "Represenation of data splits"
    def __init__(self):
        self.attribute = None
        self.subsets = {}

split1 = Split()
split2 = Split()

split1.attribute = bestAttribute(monks['monk1'], m.attributes)
print "\nCreating a 2-level tree for monk1"
print "Best attribute for split 1: ", split1.attribute

for v in split1.attribute.values:
	split1.subsets[v] = select(monks['monk1'], split1.attribute, v)
	print split1.attribute, '('+`v`+')', '#' + `len(split1.subsets[v])`


for value in split1.subsets:
	split2.attribute = bestAttribute(split1.subsets[value], [a for a in m.attributes if a!=split1.attribute])
	print "\n\tBest attribute for split 2:", split2.attribute
	for v in split2.attribute.values:
		split2.subsets[v] = select(split1.subsets[value], split2.attribute, v)
		print "\t",split1.attribute,  '('+`value`+')', '-->', split2.attribute,  '('+`v`+')', '#' + `len(split2.subsets[v])`, '-->', mostCommon(split2.subsets[v])

# 2 levels tree for monk1 using buildTree
tree =  buildTree(monks['monk1'], m.attributes, 2)
print "Tree generated by buildTree:", tree
# drawTree(tree)

# full decision trees for all monks
print "\nFull decision trees for all monks, learning from all the learning data"
print "Accuracy for training set and testing set:"
for key in sorted(monks):
	tree = buildTree(monks[key], m.attributes)
	# print tree
	print key, check(tree, monks[key]), check(tree, monktests[key])

# training and pruning

print "\nFull and pruned decision trees for all monks, learning from 0.6 of all the learning data"
print "Depth, accuracy for training set, validation set and testing set"
for key in sorted(monks):
	training, validation = partition(monks[key], 0.6)
	tree = buildTree(training, m.attributes)
	prunedTree = prune(tree, validation)
	print
	print key
	print "BEFORE",tree.depth(), check(tree, training), check(tree, validation), check(tree, monktests[key])
	print "PRUNED",prunedTree.depth(), check(prunedTree, training), check(prunedTree, validation), check(prunedTree, monktests[key])


for key in sorted(monks):
	for fraction in [0.3, 0.4, 0.5, 0.6, 0.7, 0.8]:
		training, validation = partition(monks[key], fraction)
		tree = buildTree(training, m.attributes)
		prunedTree = prune(tree, validation)
		acc1 = check(tree, monktests[key])
		acc2 = check(prunedTree, monktests[key])
		print key, fraction, acc1, acc2, (acc2-acc1)/acc2



